<!DOCTYPE html>

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<script src="/javascript/prism.js"></script>	
		<link rel="stylesheet" type="text/css" href="/css/prism.css">
		<link rel="stylesheet" type="text/css" href="/css/wecatch.css"> 
		<link rel="stylesheet" type="text/css" href="/css/mystyle.css"> 
		<title>Git常用命令</title>

		<style>
			.markdown-body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}

			@media (max-width: 767px) {
				.markdown-body {
					padding: 15px;
				}
			}
		</style>
	</head>

	<body>
		<div id="header">
			<div><a href="/">Home</a><button class="bubbly-button">toggle</button></div>
		</div>
		<article id="container">
				<div id="page">
					<div id="nav">
						<p> New pages</p>

<ul>
	

	<li>19 Mar 2019<br> <a href="/玩转EsLint">玩转EsLint</a></li>

	

	<li>19 Mar 2019<br> <a href="/ES6入门笔记2-解构赋值">ES6入门笔记2-解构赋值</a></li>

	

	<li>18 Mar 2019<br> <a href="/Git常用命令2">Git常用命令2</a></li>

	

	<li>25 Feb 2019<br> <a href="/Git常用命令">Git常用命令</a></li>

	

	<li>21 Feb 2019<br> <a href="/JS-立即执行函数表达式">JS-立即执行函数表达式</a></li>

	

	<li>20 Feb 2019<br> <a href="/ES6入门笔记">ES6入门笔记</a></li>

	

</ul>

					</div>
					<div id="content" class="markdown-body">
						<h1 id="git常用命令---git最佳实践建议">Git常用命令 - Git最佳实践建议</h1>
<p><strong>02/25/2019 Scott</strong></p>

<h4 id="commit相关的修改"><code class="highlighter-rouge">COMMIT相关的修改</code></h4>
<p>一个commit应该对应一次相关的修改内容。比如说，修复两个不一样的bug应该使用两次不同的commit。越小（修改内容）的commit能使开发人员更容易理解代码的修改或者在回退版本的时候更容易回退。</p>

<h4 id="经常commit"><code class="highlighter-rouge">经常commit</code></h4>
<p>经常使用commit能够使你的commit（里的修改内容）越小，并且能使你<strong>commit相关的修改</strong>，多次commit允许你推送自己代码到远程分支上的频率增加，能有效的减少merge代码时出现的代码冲突问题，因为多次 commit能使你的同事的代码库得到及时的更新。</p>

<h4 id="不要commit一半的工作"><code class="highlighter-rouge">不要commit一半的工作</code></h4>
<p>
当开发任务没有完整的完成的时候，不要commit。这不是说每次commit都需要开发完成一个非常完整的大功能，而是当把功能切分成许多小的但仍然具备完整性的功能点的时候，开发人员需要完整完成这个功能点之后才能commit。必要时可以使用stash命令对修改进行记录。</p>

<h4 id="commit之前的测试"><code class="highlighter-rouge">commit之前的测试</code></h4>
<p>保证你所开发的功能是完整无误的。在commit代码之前的对代码充分测试是非常重要的，可以避免有问题的代码被其他开发人员使用。</p>

<h4 id="使用commit-message"><code class="highlighter-rouge">使用commit message</code></h4>
<p>commit message的开头应该简要说明该次修改。然后换行详细描述一下两个问题的细节：</p>

<ul>
  <li>该次修改的目的？</li>
  <li>这次修改和之前的实现有何不同之处？</li>
</ul>

<h4 id="版本控制不是备份系统"><code class="highlighter-rouge">版本控制不是备份系统</code></h4>
<p>版本控制系统虽然具备了备份的功能，但开发人员不能把VCS当成一个备份系统。开发应该多关系每次commit；使用版本控制，目的是为了使每次修改有迹可循，而不是当成备份系统直接更新文件的内容。</p>

<h4 id="使用分支"><code class="highlighter-rouge">使用分支</code></h4>
<p>分支是git中一个很强大的功能。使用分支能够很好的帮助开发避免混淆不同的开发直线。开发应该在开发流程中广泛使用分支，对应不同的开发任务（比如新功能，bug修改，想法……）</p>

<h4 id="协同工作基于某个工作流程"><code class="highlighter-rouge">协同工作基于某个工作流程</code></h4>
<p>git的特性给开发人员提供了许多不同的开发流程：主分支、主题分支、merge/rebase、git-flow……。使用什么样的工作流程取决于你的项目、你的开发任务、部署流程和（更重要的）你的或者你同事的个人喜好。但只要你开始进行开发的时候，团队要统一使用一个公用的工作流程，确保每个开发能够遵守。</p>

<p><br /></p>
<h1 id="git最佳实践建议for-english">Git最佳实践建议(for English)</h1>

<h4 id="commit-related-changes"><code class="highlighter-rouge">COMMIT RELATED CHANGES</code></h4>
<p>A commit should be a wrapper for related changes. For example, fixing two different bugs should produce two separate commits. Small commits make it easier for other developers to understand the changes and roll them back if something went wrong. With tools like the staging area and the ability to stage only parts of a file, Git makes it easy to create very granular commits.</p>

<h4 id="commit-often"><code class="highlighter-rouge">COMMIT OFTEN</code></h4>
<p>Committing often keeps your commits small and, again, helps you commit only related changes. Moreover, it allows you to share your code more frequently with others. That way it‘s easier for everyone to integrate changes
regularly and avoid having merge conflicts. Having few large commits and sharing them rarely, in contrast, makes it hard to solve conflicts.</p>

<h4 id="dont-commit-half-done-work"><code class="highlighter-rouge">DON‘T COMMIT HALF-DONE WORK</code></h4>

<p>You should only commit code when it‘s completed. This doesn‘t mean you have to complete a whole, large feature before committing. Quite the contrary: split the feature‘s implementation into logical chunks and remember to commit early and often. But don‘t commit just to have something in the repository before leaving the office at the end of the day. If you‘re tempted to commit just because you need a clean working copy (to check out a branch, pull in changes, etc.) consider using Git‘s «Stash» feature instead.</p>

<h4 id="test-code-before-you-commit"><code class="highlighter-rouge">TEST CODE BEFORE YOU COMMIT</code></h4>
<p>Resist the temptation to commit something that you «think» is completed. Test it thoroughly to make sure it really is completed and has no side effects (as far as one can tell). While committing half-baked things in your local repository only requires you to forgive yourself, having your code tested is even more important when it comes to pushing/sharing your code with others.</p>

<h4 id="write-good-commit-messages"><code class="highlighter-rouge">WRITE GOOD COMMIT MESSAGES</code></h4>
<p>Begin your message with a short summary of your changes (up to 50 characters as a guideline). Separate it from the following body by including a blank line. The body of your message should provide detailed answers to the following questions:</p>

<ul>
  <li>What was the motivation for the change?</li>
  <li>How does it differ from the previous implementation? Use the imperative, present tense («change», not «changed» or «changes») to be consistent with generated messages from commands like git merge.</li>
</ul>

<h4 id="version-control-is-not-a-backup-system"><code class="highlighter-rouge">VERSION CONTROL IS NOT A BACKUP SYSTEM</code></h4>
<p>Having your files backed up on a remote server is a nice side effect of having a version control system. But you should not use your VCS like it was a backup system. When doing version control, you should pay attention to committing semantically (see «related changes») - you shouldn‘t just cram in files.</p>
<h4 id="use-branches"><code class="highlighter-rouge">USE BRANCHES</code></h4>
<p>Branching is one of Git‘s most powerful features - and this is not by accident: quick and easy branching was a central requirement from day one. Branches are the perfect tool to help you avoid mixing up different lines of development. You should use branches extensively in your development workflows: for new features, bug fixes, ideas…</p>

<h4 id="agree-on-a-workflow"><code class="highlighter-rouge">AGREE ON A WORKFLOW</code></h4>
<p>Git lets you pick from a lot of different workflows: long-running branches, topic branches, merge or rebase, git-flow… Which one you choose depends on a couple of factors: your project, your overall development and
deployment workflows and (maybe most importantly) on your and your teammates‘ personal preferences. However you choose to work, just make sure to agree on a common workflow that everyone follows.</p>

					</div>
				</div>
				
				<div id="footer">
						<div class="border"></div>
<p style="text-align:center;font-size:13px;height:20px">
    我挥舞着键盘和本子，发誓要把世界写个明明白白
</p>
<p style="text-align:center;font-size:10px;">
        Scott intofor@163.com
</p>
				</div>
		</article>
		<canvas id="mycanvas"></canvas>
		<script type="text/javascript">
			var mycanvas = document.getElementById("mycanvas");
			var ctx = mycanvas.getContext("2d");
			ctx.canvas.width = window.innerWidth;
			ctx.canvas.height = window.innerHeight;
			//圆形类
			function Circle(x, y, r, color) {
				this.x = x;
				this.y = y;
				this.r = r;
				// 颜色的取值范围
				this.color = "rgb(" + (parseInt(Math.random() * 240) + 9) + "," + (parseInt(Math.random() * 220) + 18) + ",203)";
				//随机方向
				this.dx = Math.random() * 12 - 7;
				this.dy = Math.random() * 12 - 7;
				//往数组中push自己
				circleArr.push(this);
			}
			//渲染
			Circle.prototype.render = function () {
				//新建一条路径
				ctx.beginPath();
				//创建一个圆
				ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, true);
				//设置样式颜色
				ctx.fillStyle = this.color;
				//通过填充路径的内容区域生成实心的图形
				ctx.fill();
			}
			//更新
			Circle.prototype.update = function () {
				this.x += this.dx;
				this.y += this.dy;
				this.r--;
				if (this.r < 0) {
					for (var i = 0; i < circleArr.length; i++) {
						if (circleArr[i] === this) {
							circleArr.splice(i, 1);
						};
					}
					return false;
				}
				return true;
			}
			//创建一个数组
			var circleArr = [];
			//鼠标移动事件
			window.onmousemove = function (event) {
				new Circle(event.clientX, event.clientY, 30, "orange");
			}
			//设置定时器每20毫秒更新和渲染
			setInterval(function () {
				ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)
				for (var i = 0; i < circleArr.length; i++) {
					circleArr[i].update() && circleArr[i].render();
				};
			}, 20);

			// button
			var animateButton = function (e) {
					mycanvas.style.display = mycanvas.style.display === 'none' ? 'block' : 'none';
					console.log(mycanvas.style);
					e.preventDefault;
					//reset animation
					e.target.classList.remove('animate');

					e.target.classList.add('animate');
					setTimeout(function () {
						e.target.classList.remove('animate');
					}, 700);
				};

				var bubblyButtons = document.getElementsByClassName("bubbly-button");

				for (var i = 0; i < bubblyButtons.length; i++) {
					bubblyButtons[i].addEventListener('click', animateButton, false);
				}
		</script>
	</body>

</html>
