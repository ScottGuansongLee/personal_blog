<!DOCTYPE html>

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<script src="/javascript/prism.js"></script>	
		<link rel="stylesheet" type="text/css" href="/css/prism.css">
		<link rel="stylesheet" type="text/css" href="/css/wecatch.css"> 
		<link rel="stylesheet" type="text/css" href="/css/mystyle.css"> 
		<title>ES6入门笔记</title>

		<style>
			.markdown-body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}

			@media (max-width: 767px) {
				.markdown-body {
					padding: 15px;
				}
			}
		</style>
	</head>

	<body>
		<div id="header">
			<div><a href="/">Home</a></div>
		</div>
		<article id="container">
				<div id="page">
					<div id="nav">
						<p> New pages</p>

<ul>
	

	<li>19 Mar 2019<br> <a href="/入门笔记2-解构赋值">入门笔记2-解构赋值</a></li>

	

	<li>18 Mar 2019<br> <a href="/Git常用命令2">Git常用命令2</a></li>

	

	<li>25 Feb 2019<br> <a href="/Git常用命令">Git常用命令</a></li>

	

	<li>21 Feb 2019<br> <a href="/JS-立即执行函数表达式">JS-立即执行函数表达式</a></li>

	

	<li>20 Feb 2019<br> <a href="/ES6入门笔记">ES6入门笔记</a></li>

	

</ul>

					</div>
					<div id="content" class="markdown-body">
						<h1 id="es6入门笔记">ES6入门笔记</h1>
<p><strong>02/20/2019 Scott</strong></p>

<blockquote>
  <p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
</blockquote>

<h2 id="es6-和-es2015">ES6 和 ES2015</h2>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>

<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>

<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。
<br /><br /><br /></p>

<h2 id="let命令"><code class="highlighter-rouge">let</code>命令</h2>

<p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*=====================================*/</span>
<span class="c1">//example1</span>
<span class="p">{</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">a</span> <span class="c1">// ReferenceError: a is not defined.</span>
<span class="nx">b</span> <span class="c1">// 1</span>
<span class="cm">/*=====================================*/</span>
<span class="c1">// example2</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]();</span> <span class="c1">// 10</span>
<span class="cm">/*=====================================*/</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]();</span> <span class="c1">// 6</span>
</code></pre></div></div>
<p><br /> 
var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined; let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// var 的情况</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// 输出undefined</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// let 的情况</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// 报错ReferenceError</span>
<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 在这行之前的代码块内都属于*暂时性死区*</span>
</code></pre></div></div>
<p><br />ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>

<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>

<p>“<strong>暂时性死区</strong>”也意味着<strong>typeof</strong>不再是一个百分之百安全的操作。</p>

<p>下面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p>

<p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// ReferenceError</span>
<span class="kd">let</span> <span class="nx">x</span><span class="p">;</span>

<span class="k">typeof</span> <span class="nx">undeclared_variable</span> <span class="c1">// "undefined"</span>
</code></pre></div></div>
<p><br />
let不允许在相同作用域内，重复声明同一个变量。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>

<p>但ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>

<ul>
  <li>允许在块级作用域内声明函数。</li>
  <li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
  <li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>

<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>

<p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p>

<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数声明语句</span>
<span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="s1">'secret'</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 函数表达式</span>
<span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="s1">'secret'</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /><br /><br /></p>

<h2 id="const命令"><code class="highlighter-rouge">const</code>命令</h2>

<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>

<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">PI</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
<span class="nx">PI</span> <span class="c1">// 3.1415</span>

<span class="nx">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">// TypeError: Assignment to constant variable.</span>

<span class="kd">const</span> <span class="nx">foo</span><span class="p">;</span>
<span class="c1">// SyntaxError: Missing initializer in const declaration</span>
</code></pre></div></div>

<p>const和let一样作用于相同，只在声明所在的块状作用域有效，而且存在<strong>暂时性死区</strong>。</p>

<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 为 foo 添加一个属性，可以成功</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">prop</span> <span class="c1">// 123</span>

<span class="c1">// 将 foo 指向另一个对象，就会报错</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// TypeError: "foo" is read-only</span>
</code></pre></div></div>

<p>可以使用Object.freeze方法冻结对象</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({});</span>

<span class="c1">// 常规模式时，下面一行不起作用；</span>
<span class="c1">// 严格模式时，该行会报错</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="cm">/*********一个将对象彻底冻结的函数***********/</span>
<span class="kd">var</span> <span class="nx">constantize</span> <span class="o">=</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">constantize</span><span class="p">(</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>
<span class="cm">/*****************************************/</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<ul>
  <li>ES6指的是5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等</li>
  <li>ES6新增了let和const两个命令</li>
  <li>let和const都是只在声明所在的块级作用域内有效</li>
  <li>let和const都存在暂时性死区</li>
  <li>let不存在变量提升，而var存在变量提升</li>
  <li>const在声明的时候必须赋值</li>
  <li>const指向的值一旦声明不可改变，对于const声明的复合类型的值是可变的，不可变的是const声明时所指向的数据地址</li>
  <li>Object.freeze可以冻结对象</li>
</ul>

					</div>
				</div>
				
				<div id="footer">
						<div class="border"></div>
<p style="text-align:center;font-size:13px;height:20px">
    我挥舞着键盘和本子，发誓要把世界写个明明白白
</p>
<p style="text-align:center;font-size:10px;">
        Scott intofor@163.com
</p>
				</div>
		</article>
		<canvas id="mycanvas" style="position: fixed;
						display: block;
				    top: 0px;
				    left: 0px;
				    opacity: 0.5;"></canvas>
		<script type="text/javascript">
			var mycanvas = document.getElementById("mycanvas");
			var ctx = mycanvas.getContext("2d");
			ctx.canvas.width = window.innerWidth;
			ctx.canvas.height = window.innerHeight;
			//圆形类
			function Circle(x, y, r, color) {
				this.x = x;
				this.y = y;
				this.r = r;
				// 颜色的取值范围
				this.color = "rgb(" + (parseInt(Math.random() * 240) + 9) + "," + (parseInt(Math.random() * 220) + 18) + ",203)";
				//随机方向
				this.dx = Math.random() * 12 - 7;
				this.dy = Math.random() * 12 - 7;
				//往数组中push自己
				circleArr.push(this);
			}
			//渲染
			Circle.prototype.render = function () {
				//新建一条路径
				ctx.beginPath();
				//创建一个圆
				ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, true);
				//设置样式颜色
				ctx.fillStyle = this.color;
				//通过填充路径的内容区域生成实心的图形
				ctx.fill();
			}
			//更新
			Circle.prototype.update = function () {
				this.x += this.dx;
				this.y += this.dy;
				this.r--;
				if (this.r < 0) {
					for (var i = 0; i < circleArr.length; i++) {
						if (circleArr[i] === this) {
							circleArr.splice(i, 1);
						};
					}
					return false;
				}
				return true;
			}
			//创建一个数组
			var circleArr = [];
			//鼠标移动事件
			mycanvas.onmousemove = function (event) {
				new Circle(event.clientX, event.clientY, 30, "orange");
			}
			//设置定时器每20毫秒更新和渲染
			setInterval(function () {
				ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)
				for (var i = 0; i < circleArr.length; i++) {
					circleArr[i].update() && circleArr[i].render();
				};
			}, 20);
		</script>
	</body>

</html>
